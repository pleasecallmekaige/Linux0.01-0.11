#关于SEG 指令
seg cs吧？  

先讲一下寄存器的默认组合问题，比如指令mov [si], ax表示将ax中的内容存入ds:si指向的内存单元，  
也就是说在寄存器间接寻址的情况下,以si间接寻址时总是默认以ds为相应的段地址寄存器。同样 di  
是以es为默认的段地址寄存器。我靠, 80x86的全忘记了.  
第二个要了解的是“段超越”的问题，就是在某些时候你不想使用默认的段地址寄存器，那  
么你可以强制指定一个段地址寄存器（当然这种强制是在允许的情况下，建议看一下汇编  
教材上的说明），同上例mov [si],ax表示存入ds:si中，但如果你想存入cs指向的段中可  
以这样mov cs:[si],ax， 这样就强制指定将ax中的内容存入cs:si的内存单元。  
第三个要明白的是seg cs这样的语句只影响到它下一条指令，比如在linux启动代码中的一段：  
seg cs  
mov sectors,ax  
mov ax,#INITSEG  
要说明两点：  
第一，seg cs 只影响到mov sectors,ax而不影响mov ax,#INITSEG  
第二，如果以Masm语法写，seg cs和mov sectors,ax两句合起来等  
价于mov cs:[sectors],ax，这里使用了间接寻址方式。重复一下前面  
的解释，mov [sectors],ax表示将ax中的内容存入ds:sectors内存单元，  
而mov cs:[sectors],ax强制以cs作为段地址寄存器，因此是将ax的内  
容存入cs:sectors内存单元，一般来说cs与ds的值是不同的，如果cs和  
ds的值一样，那两条指令的运行结果会是一样的。（编译后的指令后  
者比前者一般长一个字节，多了一个前缀。）
结论，seg cs只是表明紧跟它的下一条语句将使用段超越，因为在编  
译后的代码中可以清楚的看出段超越本质上就是加了一个字节的指令前缀，因此as86把它单独作为一条指令来写也是合理的。
基本情况就是这样，因为Linux使用了as86的汇编语言，与国内教科书上教的存在一些差
异。